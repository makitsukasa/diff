<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>テキスト比較ツール</title>
<style>
  :root{ --pane-width: 700px; }

  body { font-family: monospace; margin: 20px; }
  h1 { font-size: 18px; margin: 0 0 12px; }
  h3 { margin: 0 0 6px; font-size: 14px; }

  .topbar{
    display:flex; align-items:center; gap:12px;
    margin: 0 0 10px;
  }

  button{
    padding: 6px 10px;
    font-family: monospace;
    cursor: pointer;
    border: 1px solid #888;
    background: #fff;
  }
  button:disabled{
    opacity: 0.7;
    cursor: default;
  }

  .btn-inner{
    display:inline-flex;
    align-items:center;
    gap:8px;
  }

  .spinner{
    width: 14px;
    height: 14px;
    border: 2px solid #bbb;
    border-top-color: #333;
    border-radius: 50%;
    display:none;
    animation: spin 0.8s linear infinite;
  }
  button.loading .spinner{ display:inline-block; }
  @keyframes spin { to { transform: rotate(360deg); } }

  .hint{ font-size: 12px; color:#444; }

  .container { display: flex; gap: 20px; margin-bottom: 12px; }
  .pane { width: var(--pane-width); }

  textarea {
    width: var(--pane-width);
    height: 220px;
    font-family: monospace;
    white-space: pre-wrap;       /* 入力：右端で折り返す */
    overflow-wrap: break-word;
    box-sizing: border-box;
    padding: 8px;
  }

  .result-container { display: flex; gap: 20px; margin-top: 6px; }
  .result {
    width: var(--pane-width);
    border: 1px solid #ccc;
    padding: 10px;
    white-space: pre-wrap;
    overflow-wrap: break-word;
    min-height: 240px;
    line-height: 1.4;
    box-sizing: border-box;
  }

  .diff-change { background: #90EE90; } /* 緑（置換） */
  .diff-only   { background: #87CEFA; } /* 青（片側のみ） */
  .diff-gap    { background: #FFB3B3; } /* 赤（相手側に挿すスペース） */
  .diff-gap { display: inline-block; min-width: 0.6em; text-align: center; }

  button.dirty {
    background: #fff3a0;
    border-color: #d4b200;
    font-weight: bold;
  }
</style>
</head>
<body>

<h1>テキスト比較ツール</h1>

<div class="topbar">
  <button id="compareBtn">
    <span class="btn-inner">
      <span class="spinner" aria-hidden="true"></span>
      <span id="btnLabel">比較</span>
    </span>
  </button>
  <div class="hint">Ctrl+Enter でも比較します。左右に1文字以上入った最初の1回だけ自動で比較します。</div>
</div>

<div class="container">
  <div class="pane">
    <h3>左</h3>
    <textarea id="left" placeholder="左側にテキストを貼り付け"></textarea>
  </div>
  <div class="pane">
    <h3>右</h3>
    <textarea id="right" placeholder="右側にテキストを貼り付け"></textarea>
  </div>
</div>

<div class="result-container">
  <div class="result" id="result-left"></div>
  <div class="result" id="result-right"></div>
</div>

<script>
  const leftInput  = document.getElementById("left");
  const rightInput = document.getElementById("right");
  const compareBtn = document.getElementById("compareBtn");
  const btnLabel   = document.getElementById("btnLabel");
  const leftDiv    = document.getElementById("result-left");
  const rightDiv   = document.getElementById("result-right");

  // 書き換わったか
  let lastComparedLeft = "";
  let lastComparedRight = "";

  // 「左右ともに1文字以上入った最初の1回だけ」自動比較
  let didAutoCompareOnce = false;

  // ---- WebWorker（1ファイル完結のため Blob で生成）----
  const worker = createDiffWorker();

  // 最新ジョブだけ反映する（連打/複数トリガー対策）
  let jobSeq = 0;
  let running = false;

  worker.onmessage = (e) => {
    const msg = e.data || {};
    if (msg.type !== "result") return;

    // 古いジョブは捨てる
    if (msg.jobId !== jobSeq) return;

    setLoading(false);
    leftDiv.innerHTML = msg.leftHTML || "";
    rightDiv.innerHTML = msg.rightHTML || "";

    lastComparedLeft = leftInput.value;
    lastComparedRight = rightInput.value;
    checkDirtyState();
  };

  worker.onerror = (err) => {
    setLoading(false);
    console.error(err);
    alert("差分計算中にエラーが発生しました。");
  };

  // ---- トリガー ----
  compareBtn.addEventListener("click", () => runDiff());

  function onKeydown(e){
    if (e.ctrlKey && (e.key === "Enter" || e.keyCode === 13)) {
      e.preventDefault();
      runDiff();
    }
  }
  leftInput.addEventListener("keydown", onKeydown);
  rightInput.addEventListener("keydown", onKeydown);

  // 入力時：重いdiffは走らせず、「左右ともに入力された最初の1回」だけ走らせる
  function onInputLight(){
    if (didAutoCompareOnce) return;
    if (leftInput.value.length > 0 && rightInput.value.length > 0) {
      didAutoCompareOnce = true;
      runDiff();
    }
  }

  function checkDirtyState() {
    const isDirty =
      leftInput.value !== lastComparedLeft ||
      rightInput.value !== lastComparedRight;

    compareBtn.classList.toggle("dirty", isDirty);
  }

  leftInput.addEventListener("input", () => {
    onInputLight();
    checkDirtyState();
  });

  rightInput.addEventListener("input", () => {
    onInputLight();
    checkDirtyState();
  });

  function setLoading(on){
    running = on;
    compareBtn.disabled = on;
    compareBtn.classList.toggle("loading", on);
    btnLabel.textContent = on ? "⌛読込中…" : "比較";
  }

  function runDiff(){
    if (running) return;

    const left = leftInput.value;
    const right = rightInput.value;

    // 空同士でもOKだが、重さ対策として空なら即クリアでもよい
    // 今回はそのまま計算させる（軽い）
    setLoading(true);

    // 新しいジョブID
    jobSeq++;
    const currentJobId = jobSeq;

    // Workerへ投げる（DOMは触らないので固まらない）
    worker.postMessage({ type: "diff", jobId: currentJobId, left, right });
  }

  function createDiffWorker(){
    const workerCode = `
      self.onmessage = (e) => {
        const msg = e.data || {};
        if (msg.type !== "diff") return;

        const jobId = msg.jobId;
        const left = msg.left || "";
        const right = msg.right || "";

        try{
          const raw = computeDiff(left, right);
          const aligned = alignForTwoPane(raw);
          const html = renderAlignedCompressedToHTML(aligned);

          self.postMessage({
            type: "result",
            jobId,
            leftHTML: html.leftHTML,
            rightHTML: html.rightHTML
          });
        }catch(err){
          // Worker内部エラーをメインに投げる
          self.postMessage({ type: "result", jobId, leftHTML: "", rightHTML: "" });
          throw err;
        }
      };

      function computeDiff(a, b) {
        const m = a.length, n = b.length;
        const dp = Array(m + 1);
        for (let i = 0; i <= m; i++) dp[i] = new Array(n + 1).fill(0);

        for (let i = 1; i <= m; i++) {
          const ai = a.charCodeAt(i - 1);
          for (let j = 1; j <= n; j++) {
            if (ai === b.charCodeAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + 1;
            else dp[i][j] = dp[i - 1][j] >= dp[i][j - 1] ? dp[i - 1][j] : dp[i][j - 1];
          }
        }

        let i = m, j = n;
        const out = [];

        while (i > 0 && j > 0) {
          if (a[i - 1] === b[j - 1]) {
            out.unshift({ type: "same", char: a[i - 1] });
            i--; j--;
          } else if (dp[i - 1][j] >= dp[i][j - 1]) {
            out.unshift({ type: "del", char: a[i - 1] });
            i--;
          } else {
            out.unshift({ type: "add", char: b[j - 1] });
            j--;
          }
        }
        while (i > 0) { out.unshift({ type: "del", char: a[i - 1] }); i--; }
        while (j > 0) { out.unshift({ type: "add", char: b[j - 1] }); j--; }

        return out;
      }

      function alignForTwoPane(raw) {
        const rows = [];
        let idx = 0;

        while (idx < raw.length) {
          const t = raw[idx];

          if (t.type === "same") {
            rows.push({ left: { kind: "same", ch: t.char }, right: { kind: "same", ch: t.char } });
            idx++;
            continue;
          }

          const delRun = [];
          const addRun = [];
          while (idx < raw.length && raw[idx].type !== "same") {
            if (raw[idx].type === "del") delRun.push(raw[idx].char);
            else if (raw[idx].type === "add") addRun.push(raw[idx].char);
            idx++;
          }

          // 混在塊は「置換ブロック」＝全部緑。不足は空白で補う
          if (delRun.length > 0 && addRun.length > 0) {
            const maxLen = delRun.length > addRun.length ? delRun.length : addRun.length;
            for (let k = 0; k < maxLen; k++) {
              rows.push({
                left:  { kind: "change", ch: delRun[k] !== undefined ? delRun[k] : "\\u00A0" },
                right: { kind: "change", ch: addRun[k] !== undefined ? addRun[k] : "\\u00A0" }
              });
            }
          } else if (delRun.length > 0) {
            for (const ch of delRun) {
              rows.push({ left: { kind: "only", ch }, right: { kind: "gap", ch: "\\u00A0" } });
            }
          } else if (addRun.length > 0) {
            for (const ch of addRun) {
              rows.push({ left: { kind: "gap", ch: "\\u00A0" }, right: { kind: "only", ch } });
            }
          }
        }

        return rows;
      }

      // 赤スペース（gap）と緑スペース（changeで\\u00A0）の連続は1個に圧縮してHTML化
      function renderAlignedCompressedToHTML(rows){
        let leftHTML = "";
        let rightHTML = "";

        let prevLeftGap=false, prevRightGap=false;
        let prevLeftGreenSpace=false, prevRightGreenSpace=false;

        for (const r of rows) {
          // LEFT
          ({html:leftHTML, prevGap:prevLeftGap, prevGreen:prevLeftGreenSpace} =
            appendCompressed(leftHTML, r.left, prevLeftGap, prevLeftGreenSpace));

          // RIGHT
          ({html:rightHTML, prevGap:prevRightGap, prevGreen:prevRightGreenSpace} =
            appendCompressed(rightHTML, r.right, prevRightGap, prevRightGreenSpace));
        }

        return { leftHTML, rightHTML };
      }

      function appendCompressed(html, cell, prevGap, prevGreen){
        const isGap = cell.kind === "gap";
        const isGreenSpace = (cell.kind === "change" && cell.ch === "\\u00A0");

        if (isGap) {
          if (!prevGap) html += '<span class="diff-gap">&nbsp;</span>';
          return { html, prevGap:true, prevGreen:false };
        }

        if (isGreenSpace) {
          if (!prevGreen) html += '<span class="diff-change">&nbsp;</span>';
          return { html, prevGap:false, prevGreen:true };
        }

        html += renderCellInline(cell);
        return { html, prevGap:false, prevGreen:false };
      }

      function renderCellInline(cell) {
        const ch = (cell.ch === "\\u00A0") ? "&nbsp;" : escapeHtml(cell.ch);
        if (cell.kind === "same") return ch;
        if (cell.kind === "change") return '<span class="diff-change">' + ch + '</span>';
        if (cell.kind === "only") return '<span class="diff-only">' + ch + '</span>';
        if (cell.kind === "gap") return '<span class="diff-gap">' + ch + '</span>';
        return ch;
      }

      function escapeHtml(text) {
        return text
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }
    `;

    const blob = new Blob([workerCode], { type: "application/javascript" });
    const url = URL.createObjectURL(blob);
    return new Worker(url);
  }
</script>

</body>
</html>
